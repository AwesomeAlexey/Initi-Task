# Тестовое задание
___

В файле `table.h` лежит header-only код для хранения таблицы, 
добавления и удаления записей, а также для получения отсортированной части массива.

### Структура алгоритма следующая:

Клиент регулярно посылает запросы на обновление данных,
сервер сортирует часть массива и возвращает ему список строк.

### Способ сортировки:

Сначала - получение k-й порядковой статистики 
(где k - номер элемента, начиная с которого клиент запросил данные).
В результате этого получаем массив, где все элементы левее k-го
будут не больше, а все правее - не меньше.
Далее выполняется частична сортировка правой части массива,
начиная с k-го элемента, сортируются первые N элементов.

Сложность нахождения k-й порядковой статистики - `O(n)`
Сложность частичной сортировки массива - `O(n + k*log(k))`

Сложность такого подхода - `O(n + (n-k) + N*log(N))`
В худшем случае (требуются данные начиная с первого элемента)
`k = 0`, сложность `O(2*n + N*log(N))`. По мере приближения к концу массива,
сложность уменьшается до `O(n + N + N*log(N))`.
Поскольку предполагается, что `N << n`, сложность 
в конце массива можно грубо оценить как `O(n)`.


*Технически, получение k-й порядковой статистики в худшем случае 
занимает `O(n^2)`, но алгоритмы по типу ***median-of-medians*** (a.k.a. ***BFPRT***)
и его модификации позволяют гарантировано получить линейное время*

### Недостатки и возможные модификации

Бутылочное горлышко - необходимость сортировать массив для каждого клиента для каждого запроса
(если исходить из невозможности хранить копии массива, отсортированные по каждой из (требуемых) колоннок.

Возможное решение - хранить для каждого клиента пару `минимальное-максимальное` 
значения и колонку, по которой происходила сортировка. Затем, при добавлении и удалении элементов в таблицу, 
данные каждого клиента сравниваются сравниваются с новым / удаляемым значением.
Если значение не входит в диапазон - данные у клиента не меняются. В ответ на запрос с актуальностью данных,
клиент получает сообщение, что данные актуальны. 
Если же значение входит в диапазон - данные определяются заново, после вставки / удаления элемента.

В данном случае необходимо отдельно определить, что будет означать актуальность данных - 
если скроллер на середине массива, а в первую половину добавился один элемент, 
должны ли данные поменяться данные на экране или должно поменяться положение скроллера.

Данные границы диапазона также могут храниться на стороне клиента и могут отправляться в запросе.

В таком случае, в запрос необходимо добавить временную метку последнего обновления данных 
(сервер должен сам определять этот момент и отправлять в ответе на запрос клиента),
а на сервере должен храниться лог добавлений и удалений за какое-то время.
Для ответа на запрос клиента надо будет проверять каждую операцию после временной метки в 
запросе на предмет вхождения в заданный диапазон.

Опционально - при добавлении элемента, входящего в заданный диапазон, сервер может отправить отдельно этот элемент,
а клиент сам определит место вставки и удаление лишнего элемента.

